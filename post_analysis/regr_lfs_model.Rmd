---
title: 'OHIBC: Regress LFS against status, trend, prs, res'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes:
      in_header: '~/github/ohibc/src/templates/ohibc_hdr1.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'Figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')

dir_ohibc  <- '~/github/ohibc'
dir_calc   <- file.path(dir_ohibc, 'calc_ohibc')
dir_master <- file.path(dir_calc, 'master')

source(file.path(dir_calc, 'calc_scores_fxns.R'))

### provenance tracking
# library(provRmd); prov_setup()

```


# Regression model

For each goal, regress the future status (default is +5 years) against current status, trend, pressures, and resilience; this would give an idea of coefficients in the OHI LFS model; these may differ for each goal.  These do not apply to supragoals (since no pressures/resilience applied at this level), only standalone and subgoals.  Regressions will be based on the composition of the Likely Future Status calculation, using observed future state at some lag $\lambda$ rather than predicted future state.

$$ X_{future} = X_{current} [1 + \beta T + (1 - \beta) (R - P)]$$
Rearrange to
$$ Y = \frac{X_{future}}{X_{current}} = 1 + \beta T_t + (1 - \beta)(r_t - p_t)$$
In the original OHI publication, the coefficient $\beta$ was set to 0.67, assuming that recent trend is a better predictor than pressures and resilience.  To ensure an intuitive comparison of coefficients, adjust the values in `scores.csv` so that $T_t \in [-1, 1]$, and $r_t, p_t \in [0, 1]$.

Framing as regression where resilience and pressure are estimated together, and using a time horizon of $\lambda$ for likely future status:

$$ Y_t = \frac{X_{t+\lambda}}{X_{t}} = \alpha + \beta_1 T_t + \beta_2 (r_t - p_t)$$

However, if resilience and pressures are challenging to compare directly, perhaps each gets its own coefficient:
$$ Y_t = \frac{X_{t+\lambda}}{X_{t}} = \alpha + \beta_1 T_t + \beta_2 r_t + \beta_3 p_t$$
## How to understand effects of governance?

Management action and governance appear in the OHI framework as specific resilience, embedded within overall resilience.  If we can split these (either into general and specific, or social, ecological, and governance) we can examine the coefficient on each separately.

$$ Y_t = \frac{X_{t+\lambda}}{X_{t}} = \alpha + \beta_1 T_t + \beta_2 r_{spec,t} + \beta_3 r_{gen,t} + \beta_4 p_t$$

or:

$$ Y_t = \frac{X_{t+\lambda}}{X_{t}} = \alpha + \beta_1 T_t + \beta_2 r_{soc,t} + \beta_3 r_{ecol,t} + \beta_4 r_{gov,t} + \beta_5 p_t$$

## Fixed effects

Using a fixed effects model by year may compensate for exogenous unobserved variables (i.e. not included in the index calculations) that affect all regions equally in each time period, such as global economic conditions or an El NiÃ±o year.  
<!--Using a fixed effects model by region may compensate for unobserved variables (i.e. not included in index calculations) related to interregional differences, such as total population, proportion of First Nations population, or geophysical differences.-->

# Regress goal-by-goal

Assuming region scores should follow roughly similar patterns, we can include all regions for each year in the regression.

``` {r regress_lfs_coefficients}

### Set up basic data frame - make sure prs and res are 0-1; status
### range not important here since we'll take a ratio inside a loop.

# scores_rgn <- read_csv(file.path(dir_calc, 'scores_all_uncapped_res.csv')) %>%
scores_rgn <- read_csv(file.path(dir_calc, 'scores_all.csv')) %>%
  filter(region_id != 0) %>%
  spread(dimension, score) %>%
  select(goal, region_id, year, 
         pressures, resilience, 
         status, trend) %>%
  group_by(goal, region_id) %>%
  arrange(year) %>%
  mutate(pressures  = pressures  / 100,
         resilience = resilience / 100,
         res_minus_prs = resilience - pressures) %>%
  filter(!is.na(pressures) & !is.na(resilience) &!is.na(trend))

goals <-  c('AO',  
            'FIS', 'SAL', # 'MAR', ### commented out - too few years
            'CPP', 'CSS', 
            'CW',
            'HAB', 'SPP', 
            'ICO', 'LSP', 
            'LVF', 'LVO', 
            'TR')

lfs_trp <- data.frame()
lfs_res <- data.frame()
lfs_felm_yr <- data.frame()
# library(lfe)
# lfs2_all <- data.frame()
# tr_only_all <- data.frame()


for(goalname in goals) { # goalname <- goals[13]
  # cat(goalname, ': lag =', lead_yr, '\n')
  tmp_df <- scores_rgn %>%
    filter(goal == goalname) %>%
    mutate(obs_future_status = lead(status, 5),
           lfs_ratio = obs_future_status/status) %>%
    filter(!is.na(lfs_ratio))
  
  lfs_lm <- lm(lfs_ratio ~ trend + res_minus_prs, data = tmp_df) %>%
    broom::tidy() %>%
    mutate(goal  = goalname,
           n_obs = nrow(tmp_df),
           years = length(tmp_df$year %>% unique()))

  lfs_res_lm <- lm(lfs_ratio ~ resilience, data = tmp_df) %>%
    broom::tidy() %>%
    mutate(goal  = goalname,
           n_obs = nrow(tmp_df),
           years = length(tmp_df$year %>% unique()))

  if(length(tmp_df$year %>% unique()) > 1) {
    lfs_felm_yr <- lm(lfs_ratio ~ trend + res_minus_prs + factor(year), 
                      data = tmp_df) %>%
      broom::tidy() %>%
      mutate(goal  = goalname,
             n_obs = nrow(tmp_df),
             years = length(tmp_df$year %>% unique()))
  
    lfs_felm_yr <- bind_rows(lfs_felm_yr, lfs_felm_yr)
  }
  lfs_trp <- bind_rows(lfs_trp, lfs_lm)
  lfs_res <- bind_rows(lfs_res, lfs_res_lm)

}

write_csv(lfs_trp, 'int/lfs_trp.csv')
write_csv(lfs_res, 'int/lfs_res.csv')
write_csv(lfs_felm_yr, 'int/lfs_felm_yr.csv')

lfs_trp <- lfs_trp %>%
  mutate_if(is.double, ~ round(., 4))

```

## Res-Prs parameter estimates
`r DT::datatable(lfs_trp)`

<!-- ## Trend/(Pressure - Resilience) parameter estimates -->
<!-- `r # DT::datatable(lfs2_all)` -->

<!-- ## Trend-only parameter estimates -->

<!-- `r # DT::datatable(tr_only_all)` -->

# Examine resilience components

``` {r regress_lfs_coefficients_res_components}

### Set up basic data frame - make sure prs and res are 0-1; status
### range not important here since we'll take a ratio inside a loop.

res_reg <- read_csv(file.path(dir_calc, 'res_reg_only.csv')) %>%
  select(goal, region_id, year, res_reg = score)
res_soc <- read_csv(file.path(dir_calc, 'res_soc_only.csv')) %>%
  select(goal, region_id, year, res_soc = score)
res_ecol <- read_csv(file.path(dir_calc, 'res_ecol_only.csv')) %>%
  select(goal, region_id, year, res_ecol = score)
res_nonreg <- read_csv(file.path(dir_calc, 'res_nonreg_only.csv')) %>%
  select(goal, region_id, year, res_nonreg = score)

# scores_rgn <- read_csv(file.path(dir_calc, 'scores_all_uncapped_res.csv')) %>%
scores_rgn <- read_csv(file.path(dir_calc, 'scores_all.csv')) %>%
  filter(region_id != 0) %>%
  spread(dimension, score) %>%
  select(goal, region_id, year, status, trend, pressures) %>%
  left_join(res_reg, by = c('goal', 'region_id', 'year')) %>%
  left_join(res_soc, by = c('goal', 'region_id', 'year')) %>%
  left_join(res_ecol, by = c('goal', 'region_id', 'year')) %>%
  left_join(res_nonreg, by = c('goal', 'region_id', 'year')) %>%
  group_by(goal, region_id) %>%
  arrange(year) %>%
  mutate(res_reg   = res_reg / 100,
         res_soc   = res_soc / 100,
         res_ecol  = res_ecol / 100,
         res_nonreg = res_nonreg / 100,
         pressures = pressures / 100) %>%
  filter(!all(is.na(res_reg), is.na(res_soc), is.na(res_ecol)))

tmp_df <- scores_rgn %>% group_by(goal, year) %>%
  summarize(status = mean(status, na.rm = TRUE), 
            res_reg = 100 * mean(res_reg, na.rm = TRUE),
            res_soc = 100 * mean(res_soc, na.rm = TRUE),
            res_ecol = 100 * mean(res_ecol, na.rm = TRUE),
            res_nonreg = 100 * mean(res_nonreg, na.rm = TRUE),
            pressures = 100 * mean(pressures, na.rm = TRUE)) %>%
  gather(dimension, value, -goal, -year)
ggplot(tmp_df, aes(x = year, y = value, color = dimension)) +
  geom_line() +
  facet_wrap( ~ goal)

```

``` {r}

scores_rgn <- scores_rgn %>%
  filter(!is.na(res_reg))
  
goals <- scores_rgn$goal %>% 
  unique() %>%
  .[. != 'MAR'] ### remove MAR since too short of time span

lfs_res_reg <- data.frame()
lfs_res_reg_prs <- data.frame()
lfs_res_all <- data.frame()

for(yr_lag in 1:6) {
  # yr_lag <- 2
  for(goalname in goals) { # goalname <- 'LSP'
    # cat(goalname, ', lag = ', yr_lag, '\n')
    tmp_df <- scores_rgn %>%
      filter(goal == goalname) %>%
      mutate(obs_future_status = lead(status, yr_lag),
             lfs_ratio = obs_future_status/status) %>%
      filter(!is.na(lfs_ratio))
    
    tmp_mdl <- lm(lfs_ratio ~ res_reg, data = tmp_df)
    lfs_res_reg_lm <- tmp_mdl %>%
      broom::tidy() %>%
      mutate(goal  = goalname,
             n_obs = nrow(tmp_df),
             years = length(tmp_df$year %>% unique()),
             yr_lag = yr_lag,
             r_squared = summary(tmp_mdl)$adj.r.squared)
  
    tmp_mdl <- lm(lfs_ratio ~ res_reg + pressures, data = tmp_df)
    lfs_res_reg_prs_lm <- tmp_mdl %>%
      broom::tidy() %>%
      mutate(goal  = goalname,
             n_obs = nrow(tmp_df),
             years = length(tmp_df$year %>% unique()),
             yr_lag = yr_lag,
             r_squared = summary(tmp_mdl)$adj.r.squared)
  
    ### Where possible, separate ecol and soc resil; if not possible
    ### (i.e. one is all NAs) use combined non-reg resil.
    if(all(is.na(tmp_df$res_ecol)) | all(is.na(tmp_df$res_soc))) {
      tmp_mdl <- lm(lfs_ratio ~ trend + res_reg + res_nonreg + pressures, 
                    data = tmp_df)
    } else {
      tmp_mdl <- lm(lfs_ratio ~ trend + res_reg + res_soc + res_ecol + pressures, 
                    data = tmp_df)
    }
    lfs_res_all_lm <- tmp_mdl %>%
      broom::tidy() %>%
      mutate(goal  = goalname,
             n_obs = nrow(tmp_df),
             years = length(tmp_df$year %>% unique()),
             yr_lag = yr_lag,
             r_squared = summary(tmp_mdl)$adj.r.squared)

    lfs_res_reg <- bind_rows(lfs_res_reg, lfs_res_reg_lm)
    lfs_res_reg_prs <- bind_rows(lfs_res_reg_prs, lfs_res_reg_prs_lm)
    lfs_res_all <- bind_rows(lfs_res_all, lfs_res_all_lm)
  }
}

write_csv(lfs_res_reg,     'int/lfs_res_reg_only.csv')
write_csv(lfs_res_reg_prs, 'int/lfs_res_reg_prs.csv')
write_csv(lfs_res_all,     'int/lfs_res_all.csv')

DT::datatable(lfs_res_all %>% mutate_if(is.double, ~ round(., 4)))
```

# make a printable table?

## res all components

``` {r}
lfs_res_all <- read_csv('int/lfs_res_all.csv')

lfs_tbl <- lfs_res_all %>%
  mutate(sig = case_when(p.value < .0001 ~ '***',
                         p.value < .001 ~ '**',
                         p.value < .05 ~ '*',
                         p.value < .1  ~ '.',
                         TRUE ~ ''),
         val = paste0(round(estimate, 5), sig, ' (', round(std.error, 4), ')'),
         r_squared = round(r_squared, 4)) %>%
  select(term, val, goal, yr_lag, r_squared) %>%
  spread(term, val)

DT::datatable(lfs_tbl)

write_csv(lfs_tbl, 'int/lfs_res_all_formatted.csv')
```

## res_reg and prs

``` {r}
lfs_res_prs <- read_csv('int/lfs_res_reg_prs.csv')

lfs_tbl <- lfs_res_prs %>%
  mutate(sig = case_when(p.value < .0001 ~ '***',
                         p.value < .001 ~ '**',
                         p.value < .05 ~ '*',
                         p.value < .1  ~ '.',
                         TRUE ~ ''),
         val = paste0(round(estimate, 5), sig, ' (', round(std.error, 5), ')'),
         r_squared = round(r_squared, 4)) %>%
  select(term, val, goal, yr_lag, r_squared) %>%
  spread(term, val)

DT::datatable(lfs_tbl)

write_csv(lfs_tbl, 'int/lfs_res_prs_formatted.csv')
```

# Plots

## plot predicted vs observed status

``` {r}

scores <- read_csv(file.path(dir_calc, 'scores_all.csv')) %>%
  filter(region_id != 0) %>%
  spread(dimension, score) %>%
  mutate(pred_status = lag(future, 5),
         obs_status = status) %>%
  filter(nchar(goal) == 2)

ggplot(scores, aes(x = pred_status, y = obs_status, color = goal)) +
  geom_point() +
  geom_abline(yintercept = 0, slope = 1) +
  geom_smooth(method = 'lm', se = FALSE)

regr_future <- scores %>%
  group_by(goal) %>%
  do(future_mdl = lm(obs_status ~ pred_status, data = .))
```
